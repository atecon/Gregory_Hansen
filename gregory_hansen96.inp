#clear
set verbose off
/*
"Residual-based tests for cointegration in models
   with regime shifts", Journal of Econometrics (1996)
   by Allan W. Gregory and Bruce E. Hansen
   URL: http://www.ssc.wisc.edu/~bhansen/papers/joe_96.html

   B. Hansen's original GAUSS code was translated by:
   Artur Tarassow
   artur.tarassow@gmail.com
   https://sites.google.com/site/arturtarassow/code/gregory-hansen

   Function main
   #	FORMAT: call  main(y, x, model, choice, k)
   #	INPUT:      y - matrix of depend variable
   #		x 		- data matrix for independent variables (first row
is first observation)
   #		model 	- choice for model
   #					=2  C
   #					=3  C/T
   #					=4  C/S
   #		choice - only in ADF test
   #					=1  pre-specified AR lag
   #					=2  AIC-chosen AR lag
   #					=3  BIC-chosen AR lag
   #					=4  downward-t-chosen AR lag
   #		k - maximum lag for ADF test

   #	OUTPUT: print automatically Za*, breakpoint for Za*, Zt*, breakpoint for
Zt*, ADF*, breakpoint for ADF* and AR lag chosen for ADF*
   #	EXTERNAL PROCEDURES: adf,  phillips
   #	NB: Constant included in regression


   Bundle output:
   adft		: ADF* test statistics
   za		: Za test statistics
   zt		: Zt test statistics

   critadf	: Critical values for ADF*	# note: only for up to 4
regressors available
   critzt	: Critical values for Zt	# note: only for up to 4
regressors available
   critza	: Critical values for Za	# note: only for up to 4
regressors available

   bpadf 	: Breakpoint ADF* test
   bpza		: Breakpoint Za test
   bpzt		: Breakpoint Zt test

   adflag	: Determined lag length of the ADF* test

   tsadf	: Vector of estimated ADF* test stats over the trimmed sample
   tsza 	: Vector of estimated Za test stats over the trimmed sample
   tszt 	: Vector of estimated Zt test stats over the trimmed sample


   CHANGELOG:
   0.61 (May 2017)
   - load data for sample script directly from package

   0.6 (Nov. 2014)
   - minor changes
   - changed example using original data used by Gregory and Hansen
*/   


# private functions

function matrix adftest (matrix y,
                         matrix x,
                         scalar kmax,
                         scalar choice)
    # compute ADF
    scalar n=rows(y)
    bundle olsb = estim(y,x)
    #matrix b = olsb.b
    matrix e = olsb.e
    #scalar sig2 = olsb.sig2
    #matrix se = olsb.se
    matrix de=e[2:n]-e[1:n-1] 		# difference of residuals
    scalar ic=0
    scalar k=kmax
    matrix temp1 = zeros(kmax+1,1)
    matrix temp2 = zeros(kmax+1,1)
    loop while k>=0 -q
        yde = de[1+k:n-1]
        n1 = rows(yde)
        #  set up matrix for independent variable(lagged residuals)  #
        xe=e[k+1:n-1]
        scalar j=1
        loop while j <= k -q
            xe = xe ~ de[k+1-j:n-1-j]
            j=j+1
        endloop
        bundle olsb = estim(yde,xe)
        matrix b = olsb.b
        matrix e1 = olsb.e
        scalar sig2 = olsb.sig2
        matrix se = olsb.se
        if choice==1  # K is pre-specified
            temp1[k+1] = -1000   # set a random negative constant #
            temp2[k+1]=b[1]/se[1]
            break
        elif choice==2  # K is determined by AIC #
            aic=ln(e1'e1/n1)+2*(k+2)/n1
            ic=aic
        elif choice==3  # K is determined by BIC #
            bic=ln(e1'e1/n1)+(k+2)*ln(n1)/n1
            ic=bic
        elif choice==4 # K is determined by downward t #
            if abs(b[k+1]/se[k+1]) >= 1.96 || k==0
                temp1[k+1]=-1000    # set a random negative constant #
                temp2[k+1]=b[1]/se[1]
                break
            endif
        endif
        temp1[k+1]=ic
        temp2[k+1]=b[1]/se[1]
        k=k-1
    endloop
    matrix lag=iminc(temp1)
    matrix tstat=temp2[lag]
    matrix OUT = tstat ~ (lag-1)
    return OUT
end function

function matrix critza (scalar m "# of regressors",
                        scalar model "1:C, 2:C/T, 3:C/S")
    matrix RET = {}
    if model == 2
        # Critical values
        matrix CRIT_C = { -50.07 , -45.01 , -40.48 , -36.19 ; -57.01 , -51.41 , -46.98 , -42.49 ; -63.64 , -57.96 , -53.58 , -48.65 ; -70.18 , -64.41 , -59.40 , -54.38 }
        matrix RET = CRIT_C[m,]
    elif model == 3
        matrix CRIT_CT = { -57.28 , -52.09 , -47.96 , -43.22 ; -64.77 , -58.57 , -53.92 , -48.94 ; -70.27 , -64.26 , -59.76 , -54.94 ; -76.95 , -70.45 , -65.44 , -60.12 }
        matrix RET = CRIT_CT[m,]
    elif model == 4
        matrix CRIT_CS = { -57.17 , -51.32 , -47.04 , -41.85 ; -68.21 , -63.28 , -58.33 , -52.85 ; -80.15 , -73.91 , -68.94 , -63.42 ; -90.35 , -84.00 , -78.52 , -72.56 }
        matrix RET = CRIT_CS[m,]
    endif
    colnames(RET, "CV1 CV25 CV5 CV10")
    return RET
end function

function matrix critadfzt (scalar m "# of regressors",
                           scalar model "2:C, 3:C/T, 4:C/S")
    matrix RET = {}
    if model == 2
        # Critical values
        matrix CRIT_C = { -5.13 , -4.83 , -4.61 , -4.34 ; -5.44 , -5.16 , -4.92 , -4.69 ; -5.77 , -5.50 , -5.28 , -5.02 ; -6.05 , -5.80 , -5.56 , -5.31 }
        matrix RET = CRIT_C[m,]
    elif model == 3
        matrix CRIT_CT = { -5.45 , -5.21 , -4.99 , -4.72 ; -5.80 , -5.51 , -5.29 , -5.03 ; -6.05 , -5.79 , -5.57 , -5.33 ; -6.36 , -6.07 , -5.83 , -5.59 }
        matrix RET = CRIT_CT[m,]
    elif model == 4
        matrix CRIT_CS = { -5.47 , -5.19 , -4.95 , -4.68 ; -5.97 , -5.73 , -5.50 , -5.23 ; -6.51 , -6.23 , -6.00 , -5.75 ; -6.92 , -6.64 , -6.41 , -6.17 }
        RET = CRIT_CS[m,]
    endif
    colnames(RET, "CV1 CV25 CV5 CV10")
    return RET
end function

function bundle estim (matrix y,
                       matrix x)
    bundle bund = null
    m = invpd(x'*x)
    b = mols(y,x)
    bund.b = b
    e = y - x*b
    sig2=(e'e)/(rows(y)-cols(x))
    se = sqrt(diag(m)*sig2)
    bund.e = e
    bund.sig2 = sig2
    bund.se = se
    return bund
end function

function matrix phillips (matrix y,
                          matrix x)
    scalar n=rows(y)
    #  OLS regression
    matrix b = mols(y,x,null, null)
    matrix e = y - x*b
    #  OLS regression on residuals
    matrix be = e[2:n]\e[1:n-1]
    matrix ue = e[2:n] - e[1:n-1]*be
    # calculate bandwidth number
    scalar nu = rows(ue)
    matrix bu=ue[2:nu]\ue[1:nu-1]
    matrix uu=ue[2:nu]-ue[1:nu-1].*bu
    matrix su=meanc(uu.^2)
    scalar a2=(4*bu^2*su/(1-bu)^8)/(su/(1-bu)^4)
    scalar bandwidth=1.3221*((a2*nu)^0.2)
    scalar m = bandwidth
    scalar j=1
    scalar lemda=0
    loop while j<=m -q
        matrix gama=ue[1:nu-j]'ue[j+1:nu]/nu
        scalar c = j/m
        scalar w=(75/(6*pi*c)^2)*(sin(1.2*pi*c)/(1.2*pi*c)-cos(1.2*pi*c))
        scalar lemda = lemda + w*gama
        j = j + 1
    endloop
    # calculate Za and Zt for each t
    scalar p=sumc(e[1:n-1].*e[2:n]-lemda)/sumc(e[1:n-1].^2)
    matrix za = n*(p-1)
    matrix sigma2 = 2*lemda+ue'ue/nu
    s = sigma2/(e[1:n-1]'e[1:n-1])
    matrix zt=(p-1)/sqrt(s)
    OUT = za ~ zt
    return OUT
end function

# public functions

function bundle main (matrix y,
                      matrix x,
                      int model,
                      int choice,
                      int k)
    bundle cbreak
    scalar n = rows(y)
    scalar begin=round(0.15*n)
    scalar final=round(0.85*n)
    matrix temp1=zeros((final-begin+1),1)
    temp2 = temp1
    temp3 = temp1
    temp4 = temp1
    scalar t = begin
    loop while t<=final -q
        matrix dummy = zeros(t,1) | ones((n-t),1)
        # adjust regressors for different models
        if model==3			# C/T
            matrix x1 = ones(n,1) ~ dummy ~ seq(1,n)' ~ x
        elif model==4		# C/S
            matrix x1 = ones(n,1) ~ dummy ~ x ~ dummy.*x
        elif model==2		# C
            matrix x1 = ones(n,1) ~ dummy ~ x
        endif
        # computer ADF for each t
        mtmp = adftest(y,x1,k,choice)
        temp1[t-begin+1] = mtmp[1]		# teststat
        temp2[t-begin+1] = mtmp[2]		# lag-order of ADF test
        # compute Za or Zt for each t
        mtmp = phillips(y,x1)
        temp3[t-begin+1] = mtmp[1]
        temp4[t-begin+1] = mtmp[2]
        t=t+1
    endloop
    #  ADF test
    scalar tstat = minc(temp1)
    scalar lag = iminc(temp1)
    scalar breakpta = (lag+begin-1)/n
    scalar lag = temp2[lag]
    scalar mnum = cols(x)
    if mnum <= 4
        matrix critA = critadfzt(mnum,model)
    endif
    printf "******** ADF Test ***********\n"
    printf "t-statistic = %.3f\n", tstat
    printf "AR lag = %d\n", lag
    printf "break point (ADF) = %.2f\n", breakpta
    if mnum <= 4
        printf "Critical values (ADF): \n"
        printf "CV 0.01 = %6.3f \n", critA[1]
        printf "CV 0.025 = %6.3f \n", critA[2]
        printf "CV 0.05 = %6.3f \n", critA[3]
        printf "CV 0.10 = %6.3f\n", critA[4]
    endif
    printf "\n"
    #  Phillips test
    scalar za = minc(temp3)
    scalar breakpt1 = (iminc(temp3)+begin-1)/n
    scalar zt = minc(temp4)
    scalar breakpt2 = (iminc(temp4)+begin-1)/n
    if mnum <= 4
        matrix critB = critza(mnum,model)
    endif
    printf "******** Phillips Test ********\n"
    printf "Zt =            %.3f\n", zt
    printf "breakpoint (Zt) =  %.2f\n", breakpt2
    if mnum <= 4
        printf "Critical values (Zt): \n"
        printf "CV 0.01 = %6.3f \n", critA[1]
        printf "CV 0.025 = %6.3f \n", critA[2]
        printf "CV 0.05 = %6.3f \n", critA[3]
        printf "CV 0.10 = %6.3f\n", critA[4]
    endif
    printf "\n"
    printf "Za =              %.3f\n", za
    printf "breakpoint(Za) = %.2f\n", breakpt1
    if mnum <= 4
        printf "Critical values (Za): \n"
        printf "CV 0.01 = %6.3f \n", critB[1]
        printf "CV 0.025 = %6.3f \n", critB[2]
        printf "CV 0.05 = %6.3f \n", critB[3]
        printf "CV 0.10 = %6.3f\n", critB[4]
    endif
    printf "\n"
    # Assemble bundle
    cbreak.adft = tstat
    cbreak.adflag = lag
    cbreak.bpadf = breakpta
    cbreak.tsadf = temp1
    cbreak.zt = zt
    cbreak.bpzt = breakpt2
    cbreak.tszt = temp4
    cbreak.za = za
    cbreak.bpza = breakpt1
    cbreak.tsza = temp3
    cbreak.critadf = critA
    cbreak.critzt = critA
    cbreak.critzt = critB
    # Plot
    matrix mplot = temp1 ~ temp3 ~ temp4
    colnames(mplot, "ADF* Za Zt")
    string DET = ""
    if choice==2
        DET = "C"
    elif choice==3
        DET = "C/T"
    else
        DET = "C/S"
    endif
    return cbreak
end function



/*
#################
#	 EXAMPLE: "Residual-based tests for cointegration in models with regime shifts"
#    by Allan W. Gregory and Bruce E. Hansen	#
#################
set verbose off
include gregory_hansen.gfn

open joe96_data.gdt --frompkg=gregory_hansen
rename xx3 ynr			# Net National Product, Billions of 82$
rename xx2 pp			# Implicit Price Deflator, PI
rename xx1 m1			# m1/p - M1, Billions of $
rename xx4 sr			# 3 Month T-Bills

series md = log(m1)
series ynr = log(ynr)

smpl 1960:1 1990:4		# Sample selected in the original article

matrix y = { md }	# Endogeneous
matrix x = { ynr } ~ { sr }	# Exogenous

# Setup; main(y,x,model,choice,k)

scalar model = 4		# Select break-type: 2=C, 3=C/T, 4=C/S
# CHOICE only ADF*-test
# =1  pre-specified AR lag
# =2  AIC-chosen AR lag
# =3  BIC-chosen AR lag
# =4  downward-t-chosen AR lag
scalar choice = 2		# only for ADF*-test relevant
scalar k = 6			# maximum lag for ADF test
greghans = main(y,x,model,choice,k)

# Plot regime shift
matrix mplot = greghans.tsadf ~ greghans.tsza ~ greghans.tszt
colnames(mplot, "adf* z_a z_t")

plot mplot
    options with-lp time-series
    literal set title "Regime shifts with ADF*, Za and Zt"
end plot --output=display

# Conventional ADF Test
coint k md ynr sr --test-down --skip-df
coint k md ynr sr --ct --test-down --skip-df
*/
